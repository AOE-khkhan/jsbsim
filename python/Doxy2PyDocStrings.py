# Doxy2PyDocsStrings.py
#
# Convert the C++ documentation generated by Doxygen to Python docs strings.
# This saves the manual synchronization between the C++ code documentation and
# Python doc strings.
#
# Copyright (c) 2019 Bertrand Coconnier
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <http://www.gnu.org/licenses/>
#

import re
from textwrap import wrap
import xml.etree.ElementTree as et

version = '_'+'_'.join('${PROJECT_VERSION}'.split('.')[:2])

def wrap_last_line(txt, tab):
    col = txt.rfind('\n'+tab)+len(tab)+1
    lastline = txt[col:].strip()
    n = len(tab)
    if len(lastline) > 80-n:
        return txt[:col]+('\n'+' '*n).join(wrap(lastline, 80-n))

    return txt

def convert_para(tag, indent):
    docstring = ''
    tab = ' '*indent
    for para in tag.findall('para'):
        docstring += '\n\n'+tab
        if para.text:
            docstring += ('\n'+tab).join(wrap(para.text, 80-indent))
        for elem in para.iter():
            if elem.tag == 'itemizedlist':
                for item in elem.findall('listitem'):
                    docstring += tab+'* '+convert_para(item, indent+2)
            elif elem.tag == 'programlisting':
                docstring = docstring[:-2-indent]+' ::\n\n'
                for codeline in elem.findall('codeline/highlight'):
                    if codeline.text:
                        docstring += ' '*(indent+2)+codeline.text.strip()
                    for sp in codeline.findall('sp'):
                        docstring += ' '
                        if sp.tail:
                            docstring += sp.tail.strip()
                    docstring +='\n'
                if elem.tail:
                    docstring += elem.tail
                else:
                    # Remove the last carriage return
                    docstring = docstring[:-1]
            # TODO: Make a link from <ref>
            elif elem.tag == 'ref':
                docstring += ' '+elem.text
                if elem.tail:
                    docstring += elem.tail
                docstring = wrap_last_line(docstring, tab)
            elif elem.tag == 'simplesect' and elem.attrib['kind'] == 'return':
                ret = elem.find('para')
                if ret is not None and ret.text:
                    if docstring.rstrip():
                        docstring +='\n\n'+tab
                    docstring += ':returns: '+ret.text+'\n'

    return docstring

with open('jsbsim.pyx') as source:
    txt = source.read()

klasses = re.findall(r'cdef\s+class\s+(\w+)', txt)

# Autogenerate the documentation page for each class
for klass in klasses:
    with open('${CMAKE_CURRENT_BINARY_DIR}/documentation/'+klass+'.rst', 'w') as f:
        title = klass
        f.write("="*len(title)+'\n'+title+'\n'+"="*len(title)+'\n\n')
        f.write('.. autoclass:: jsbsim.'+klass+'\n   :members:\n')

doxytag = re.search(r'@Dox\(([\w:]+)\)', txt)

while doxytag:
    names = doxytag.group(1).split('::')
    xmlfilename = 'class'+version.join(names[:2])+'.xml'
    tree = et.parse('${CMAKE_CURRENT_BINARY_DIR}/documentation/xml/'+xmlfilename)
    root = tree.getroot()
    docstring = ''
    col = doxytag.start() - txt[:doxytag.start()].rfind('\n')

    for tag in root.findall('compounddef/compoundname'):
        if tag.text != '::'.join(names[:2]):
            raise IOError("File {} does not contain {}".format(xmlfilename,
                                                               doxytag.group(1)))

    if len(names) == 2:
        # Class docs
        member = root.find('compounddef')
    else:
        # Member function docs
        for member in root.findall('.//memberdef'):
            if member.find('name').text == names[2]:
                break
        else:
            raise IOError("Could not find {} in {}".format(doxytag.group(1),
                                                           xmlfilename))
    para = member.find('briefdescription/para')
    if para is not None and para.text:
        docstring = para.text.strip()

    tag = member.find('detaileddescription')
    if tag is not None:
        docstring += convert_para(tag, col-1)

    if len(docstring) == 0:
        docstring = 'Not yet documented.'

    txt = txt[:doxytag.start()]+txt[doxytag.start():].replace(doxytag.group(),
                                                              docstring.rstrip())
    doxytag = re.search(r'@Dox\(([\w:]+)\)', txt)

with open('jsbsim.pyx', 'w') as dest:
    dest.write(txt)

