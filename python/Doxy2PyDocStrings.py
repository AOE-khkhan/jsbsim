# Doxy2PyDocsStrings.py
#
# Convert the C++ documentation generated by Doxygen to Python docs strings.
# This saves the manual synchronization between the C++ code documentation and
# Python doc strings.
#
# Copyright (c) 2019 Bertrand Coconnier
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <http://www.gnu.org/licenses/>
#

import re
from textwrap import wrap
import xml.etree.ElementTree as et

version = '_'+'_'.join('${PROJECT_VERSION}'.split('.')[:2])

def convert_para(tag, indent):
    docstring = ''
    for para in tag.findall('para'):
        docstring += ' '*indent
        if para.text:
            docstring += ('\n'+' '*indent).join(wrap(para.text, 80-indent))
        for item_list in para.findall('itemizedlist'):
            for item in item_list.findall('listitem'):
                docstring += convert_para(item, indent)
        listings = para.findall('programlisting')
        if listings:
            for listing in listings:
                docstring = docstring[:-2-indent]+' ::\n\n'
                for codeline in listing.findall('codeline/highlight'):
                    if codeline.text:
                        docstring += ' '*(indent+2)+codeline.text.strip()
                    for sp in codeline.findall('sp'):
                        docstring += ' '
                        if sp.tail:
                            docstring += sp.tail.strip()
                    docstring +='\n'
                if listing.tail:
                    docstring += listing.tail.strip()
                docstring += '\n'
        elif docstring.rstrip():
            docstring += '\n\n'
        ret = para.find('simplesect[@kind="return"]/para')
        if ret is not None and ret.text:
            if docstring.rstrip():
                docstring +=' '*indent
            docstring += ':returns: '+ret.text+'\n'

    return docstring

with open('jsbsim.pyx') as source:
    txt = source.read()

doxytag = re.search(r'@Dox\(([\w:]+)\)', txt)

while doxytag:
    names = doxytag.group(1).split('::')
    xmlfilename = 'class'+version.join(names[:2])+'.xml'
    tree = et.parse('${CMAKE_CURRENT_BINARY_DIR}/documentation/xml/'+xmlfilename)
    root = tree.getroot()
    docstring = ''
    col = doxytag.start() - txt[:doxytag.start()].rfind('\n')

    for tag in root.findall('compounddef/compoundname'):
        if tag.text != '::'.join(names[:2]):
            raise IOError("File {} does not contain {}".format(xmlfilename,
                                                               doxytag.group(1)))

    if len(names) == 2:
        # Class docs
        member = root.find('compounddef')
    else:
        # Member function docs
        for member in root.findall('.//memberdef'):
            if member.find('name').text == names[2]:
                break
        else:
            raise IOError("Could not find {} in {}".format(doxytag.group(1),
                                                           xmlfilename))
    para = member.find('briefdescription/para')
    if para is not None and para.text:
        docstring = para.text.strip()+'\n\n'

    tag = member.find('detaileddescription')
    if tag is not None:
        docstring += convert_para(tag, col-1)

    if len(docstring) == 0:
        docstring = 'Not yet documented.'

    txt = txt[:doxytag.start()]+txt[doxytag.start():].replace(doxytag.group(),
                                                              docstring.rstrip())
    doxytag = re.search(r'@Dox\(([\w:]+)\)', txt)

with open('jsbsim.pyx', 'w') as dest:
    dest.write(txt)

